Right. Its been a while since I've used these so be aware. Furthermore one of Scott's PhD students was let loose on these codes shortly after I switched off working with CoMP; one or two minor bugs were found and squashed, plus the codes themselves were generally tidied up. I'll try and root out that version if I get chance, but for now you can have the version I worked on in Boulder in late 2012.

Setting up: for these codes to work, you would need to have the data formatted in "La Palma" datacubes. I found that this is easier for limited memory machines to handle, despite the overall file sizes remaining relatively large. This means you should be familiar with the "lp_read/lp_write/etc commands". I've attached the lp_* commands in case you're not familiar with these cubes.

CODE NOTES:
Before running this code, I resave each of the CoMP quantities (e.g. intensity, line-width, doppler) into a set of full disk fcubes, then cut out (and re-save as smaller fcubes) a certain region of interest. These are the quantities loaded in at the start.
The "Looptracker" section loads a set of points onto a picture of the small region of interest, and then attempts to fit a spline to these points. Once this happens, the arcsample stage increases the number of sample points along the arc until the sample points are spaced as close to (or below) the observational grid.
Once the arc resolution has been fixed, the code works out the angle between two consecutive points and the vertical, before rotating THE WHOLE DATACUBE to this angle (so that the chosen arc is now fully vertical, and hence you can sample pixels perpendicular to the arc by simply doing a horizontal cut at the present coordinate). You then move to the next arc coordinate and repeat until the arc is done. Finally, as its going along, I not only sample the original data values, but those of unsharp masked data, running differenced data, and any other of your favourite image processing tricks, and store this data in separate cubes. In previous talks about this code, I sort of think of it as like a sewing machine - the sampling happens at one place only, while you move the surface around to form the pattern you want, at the spacing you want.

I cut the data down to a "small" region of interest because of the need to rotate the data - this will work (slowly) on full disk datasets, but is generally easier if we chop off >3/4's of the data, obviously (I made up this code on a laptop, hence my memory stinginess).
